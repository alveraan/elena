import re


class EntityWriter:
    """
    Converts the data structure generated by MapEntitiesParser into a
    string (when using to_string) or writes it to a file (when using
    write_to_file).

    You can optionally specify the character(s) used for indentation.
    """
    def __init__(self, indent:str='\t') -> None:
        self.nl = '\n'
        self.indent = indent
        self._re_nr = re.compile(r"^[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?$")

    def write_to_file(self, map:"EntitiesMap", filepath:str,
                      includer_header:bool=True) -> None:
        with open(filepath, 'w', newline=self.nl) as f:
            f.write(self.to_string(map, includer_header))

    def to_string(self, map:"EntitiesMap", include_header:bool=True) -> str:
        output = ''
        if include_header:
            version = f'Version {map.version}{self.nl}'
            h_version = f'HierarchyVersion {map.hierarchy_version}{self.nl}'
            output += version + h_version
            output += self._properties_to_str(map.properties)
        # we need to use \n newlines, otherwise oodle has problems,
        # producing additional empty newlines with each compression /
        # decompression cycle.
        entities = self.entities_to_str(map.entities)
        entities = entities.replace('\r\n', self.nl)
        output += entities

        return output

    def _properties_to_str(self, properties:list) -> str:
        if len(properties) == 0:
            return ''
        s = f'properties {{{self.nl}'
        for property in properties:
            for key, value in property.items():
                s += f'{self.indent}"{key}" = "{value}"{self.nl}}}{self.nl}'

        return s

    def entities_to_str(self, entities:list) -> str:
        parts = []
        for entity in entities:
            parts.append(f'entity {{{self.nl}')
            parts.append(self._entity_to_str_recursive(entity))
            parts.append(f'}}{self.nl}')
        return ''.join(parts)

    def _entity_to_str_recursive(self, entity:dict, level:int=1) -> str:
        s = ''
        for key, value in entity.items():
            if level == 1 and key == 'layers':
                if len(value) > 0:
                    s += self._layers_to_str(value)
                continue

            s += self.indent * level
            s += key

            if isinstance(value, dict):
                if key.startswith('entityDef '):
                    s += f' {{{self.nl}'
                else:
                    s += f' = {{{self.nl}'
                s += self._entity_to_str_recursive(value, level + 1)
            else:
                s += f' = {self._format_value(value)};{self.nl}'

        if level != 1:
            s += f'{self.indent * (level - 1)} }}{self.nl}'

        return s
    
    def _format_value(self, value:bool|int|float|str|None) -> str:
        if value is True:
            value = 'true'
        elif value is False:
            value = 'false'
        elif value is None:
            value = 'NULL'
        elif self._is_number(str(value)):
            value = str(value)
        else:
            value = f'"{str(value)}"'
        
        return value
    
    def _layers_to_str(self, layers:list) -> str:
        s = ''
        s += f'{self.indent}layers {{{self.nl}'
        for layer in layers:
            s += f'{self.indent * 2}"{layer}"{self.nl}'
        s += f'{self.indent}}}{self.nl}'
        
        return s
    
    def _is_number(self, value:str) -> bool:
        return self._re_nr.match(value) is not None
